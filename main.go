// Code generated by hertz generator.

package main

import (
	"bytes"
	"context"
	"dogker/lintang/container-service/biz/dal"
	"dogker/lintang/container-service/biz/dal/db"
	"dogker/lintang/container-service/biz/domain"
	"dogker/lintang/container-service/biz/router"
	"dogker/lintang/container-service/config"
	"dogker/lintang/container-service/di"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"time"

	hertzzap "github.com/hertz-contrib/logger/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/app/server"
	"github.com/cloudwego/hertz/pkg/app/server/binding"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/natefinch/lumberjack"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"

	_ "github.com/jackc/pgx/v5/stdlib"
)

func main() {
	cfg, err := config.NewConfig()
	logsCores := initZapLogger(cfg)
	defer logsCores.Sync()
	hlog.SetLogger(logsCores)
	zap.L().Info("halo dunia", zap.String("nama", "lintang"))

	if err != nil {
		hlog.Fatalf("Config error: %s", err)
	}
	pg := dal.InitPg(cfg) // init postgres & rabbitmq
	rmq := dal.InitRmq(cfg)

	cc, err := grpc.NewClient(cfg.GRPC.MonitorURL+"?wait=30s", grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		zap.L().Fatal("Newclient gprc (main)", zap.Error(err) )
	}
	// validation error custom
	customValidationErr := CreateCustomValidationError()

	h := server.Default(server.WithValidateConfig(customValidationErr))

	h.Use(AccessLog())

	cSvc := di.InitContainerService(pg, rmq, cfg, cc)
	InstallCURLInDkron()


	router.MyRouter(h, cSvc)
	h.Spin()
	// gracefulShutdown
	h.SetCustomSignalWaiter(func(err chan error) error {
		db.ClosePostgres(pg.Pool)
		rmq.Close()
		cc.Close()
		return nil
	})


}

var lg *zap.Logger

// pake hertzlogger gak kayak pake uber/zap logger beneran
func initZapLogger(cfg *config.Config) *hertzzap.Logger {
	productionCfg := zap.NewProductionEncoderConfig()
	productionCfg.TimeKey = "timestamp"
	productionCfg.EncodeTime = zapcore.ISO8601TimeEncoder
	productionCfg.EncodeDuration = zapcore.SecondsDurationEncoder
	productionCfg.EncodeCaller = zapcore.ShortCallerEncoder

	developmentCfg := zap.NewDevelopmentEncoderConfig()
	developmentCfg.EncodeLevel = zapcore.CapitalColorLevelEncoder

	// log encooder (json for prod, console for dev)
	consoleEncoder := zapcore.NewConsoleEncoder(developmentCfg)
	fileEncoder := zapcore.NewJSONEncoder(productionCfg)
	// loglevel
	logDevLevel := zap.NewAtomicLevelAt(zap.DebugLevel)
	logLevelProd := zap.NewAtomicLevelAt(zap.InfoLevel)

	//write sycer
	writeSyncerStdout, writeSyncerFile := getLogWriter(cfg.MaxBackups, cfg.MaxAge)

	prodCfg := hertzzap.CoreConfig{
		Enc: fileEncoder,
		Ws:  writeSyncerFile,
		Lvl: logLevelProd,
	}

	devCfg := hertzzap.CoreConfig{
		Enc: consoleEncoder,
		Ws:  writeSyncerStdout,
		Lvl: logDevLevel,
	}
	logsCores := []hertzzap.CoreConfig{
		prodCfg,
		devCfg,
	}
	coreConsole := zapcore.NewCore(consoleEncoder, writeSyncerStdout, logDevLevel)
	coreFile := zapcore.NewCore(fileEncoder, writeSyncerFile, logLevelProd)
	core := zapcore.NewTee(
		coreConsole,
		coreFile,
	)
	lg = zap.New(core)
	zap.ReplaceGlobals(lg)

	prodAndDevLogger := hertzzap.NewLogger(hertzzap.WithZapOptions(zap.WithFatalHook(zapcore.WriteThenPanic)),
		hertzzap.WithCores(logsCores...))

	return prodAndDevLogger
}

func getLogWriter(maxBackup, maxAge int) (writeSyncerStdout zapcore.WriteSyncer, writeSyncerFile zapcore.WriteSyncer) {
	file := zapcore.AddSync(&lumberjack.Logger{
		Filename: "./logs/app.log",

		MaxBackups: maxBackup,
		MaxAge:     maxAge,
	})
	stdout := zapcore.AddSync(os.Stdout)

	return stdout, file
}

type ValidateError struct {
	ErrType, FailField, Msg string
}

// Error implements error interface.
func (e *ValidateError) Error() string {
	if e.Msg != "" {
		return e.Msg
	}
	return e.ErrType + ": expr_path=" + e.FailField + ", cause=invalid"
}

type BindError struct {
	ErrType, FailField, Msg string
}

// Error implements error interface.
func (e *BindError) Error() string {
	if e.Msg != "" {
		return e.Msg
	}
	return e.ErrType + ": expr_path=" + e.FailField + ", cause=invalid"
}

func CreateCustomValidationError() *binding.ValidateConfig {
	validateConfig := &binding.ValidateConfig{}
	validateConfig.SetValidatorErrorFactory(func(failField, msg string) error {
		err := ValidateError{
			ErrType:   "validateErr",
			FailField: "[validateFailField]: " + failField,
			Msg:       msg,
		}

		return &err
	})
	return validateConfig
}

// accessLogger nbawaan zap bagus ini pas di load testing
func AccessLog() app.HandlerFunc {
	return func(c context.Context, ctx *app.RequestContext) {
		start := time.Now()
		path := string(ctx.Request.URI().Path()[:])
		query := string(ctx.Request.URI().QueryString()[:])
		ctx.Next(c)
		cost := time.Since(start)
		lg.Info(path,
			zap.Int("status", ctx.Response.StatusCode()),
			zap.String("method", string(ctx.Request.Header.Method())),
			zap.String("path", path),
			zap.String("query", query),
			zap.String("ip", ctx.ClientIP()),
			zap.String("user-agent", string(ctx.Host())),
			zap.String("errors", ctx.Errors.String()),
			zap.Duration("cost", cost),
		)
	}
}

// // bawaan hertz
// func AccessLog() app.HandlerFunc {
// 	return func(c context.Context, ctx *app.RequestContext) {
// 		start := time.Now()
// 		ctx.Next(c)
// 		end := time.Now()
// 		latency := end.Sub(start).Milliseconds()
// 		hlog.CtxTracef(c, "status=%d cost=%d method=%s full_path=%s client_ip=%s host=%s method=%s",
// 			ctx.Response.StatusCode(), latency,
// 			ctx.Request.Header.Method(), ctx.Request.URI().PathOriginal(), ctx.ClientIP(), ctx.Request.Host(), string(ctx.Request.Header.Method()))
// 	}
// }

type JobReq struct {
	Name           string            `json:"name"`
	DisplayName    string            `json:"displayname"`
	Schedule       string            `json:"schedule"`
	Timezone       string            `json:"timezone"`
	Owner          string            `json:"owner"`
	OwnerEmail     string            `json:"owner_email"`
	Disabled       bool              `json:"disabled"`
	Concurrency    string            `json:"concurrency"`
	Executor       string            `json:"executor"`
	ExecutorConfig map[string]string `json:"executor_config"`
}

func InstallCURLInDkron() error {
	at := time.Now().Add(2 * time.Second)

	payload, err := json.Marshal(JobReq{
		Name:        "insatll curl",
		DisplayName: "insatll curl",
		Schedule:    fmt.Sprintf("@at " + at.Format(time.RFC3339)),
		Timezone:    "Asia/Jakarta",
		Owner:       "lintang birda saputra",
		OwnerEmail:  "lintangbirdasaputra23@gmail.com",
		Disabled:    false,
		Concurrency: "allow",
		Executor:    "shell",
		ExecutorConfig: map[string]string{
			"command": `sh /curl/curl.sh'`,
		},
	})
	if err != nil {
		zap.L().Error("Marshal JSON", zap.Error(err))
		return domain.WrapErrorf(err, domain.ErrInternalServerError, domain.MessageInternalServerError)
	}

	req, err := http.NewRequest("POST", "http://dkron:8080/v1/jobs", bytes.NewBuffer(payload))

	if err != nil {
		zap.L().Error("NewRequest ", zap.Error(err))
		return domain.WrapErrorf(err, domain.ErrInternalServerError, domain.MessageInternalServerError)
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		zap.L().Error("client.Do(req) ", zap.Error(err))
		return domain.WrapErrorf(err, domain.ErrInternalServerError, domain.MessageInternalServerError)
	}
	defer resp.Body.Close()
	zap.L().Info("Successfully installl curl in dkron")
	return nil
}
